# Организация и тестирование кода

В этой главе мы сосредоточим внимание на важных темах сохранения кода удобным для поддержки в масштабируемом приложении. Вы узнаете об организации кода, чтобы освоить лучшие способы структурирования ваших папок и файлов. Ещё один аспект, который вы узнаете, — это тестирование, которое важно для написания надёжного кода. Наконец, вы узнаете о полезном инструменте для отладки ваших React-приложений. Бо́льшая часть главы отойдёт в сторону от практического приложения и объяснит вам пару этих тем.

## Модули ES6: импорт и экспорт

В JavaScript ES6 вы можете импортировать и экспортировать функциональность из модулей. Этой функциональностью могут быть функции, классы, компоненты, константы и т.д. В основном это всё то, что вы можете присвоить переменной. Модули могут быть отдельными файлами или целыми папками с одним индексным файлом (index.js) в качестве точки входа.

В начале книги после того, как вы инициализировали приложение с помощью *create-react-app*, вы уже сталкивались с несколькими выражениями `import` и `export` в ваших файлах исходного кода. Настало время объяснить, зачем всё это.

Выражения `import` и `export` помогают распространять код между несколькими файлами. Раньше в среде JavaScript было несколько решений для этой цели. Это был беспорядок, потому что вы, вероятно, хотели бы следовать стандартизированному способу, а не иметь несколько подходов к одному и тому же. Теперь это нативная возможность, начиная с JavaScript ES6.

Кроме того, эти выражения охватывает идею разделения кода. Вы разделяете свой код между несколькими файлами для возможности сделать его многоразовым и поддерживаемым. Первое верно, потому что вы можете импортировать часть кода в несколько файлов. Последнее верно, потому что у вас есть один источник, в котором вы поддерживаете часть кода.

И последнее, но не менее важное: это поможет вам подумать о инкапсуляции кода. Не каждая функциональность должна быть экспортирована из файла. Некоторые из этих функциональных возможностей должны использоваться только в файле, где они были определены. Экспорт файла в основном означает общедоступный API для использования в другом файле. Доступны для повторного использования в другом месте кодовой базы только экспортированные функциональные возможности. Это следует передовой практике инкапсуляции.

Но давайте перейдём к практике. Как эти выражения `import` и `export` работают? В следующих примерах приводятся выражения, совместно использующие одну или несколько переменных в двух файлах. В конце концов, этот подход можно масштабировать на несколько файлов и обмениваться не только простыми переменными.

Вы можете экспортировать одну или несколько переменных. Это называется именованным экспортом.

{title="Код: file1.js",lang="javascript"}
~~~~~~~~
const firstname = 'Robin';
const lastname = 'Wieruch';

export { firstname, lastname };
~~~~~~~~

И импортируйте их в другой файл с помощью относительного пути к первому файлу.

{title="Код: file2.js",lang="javascript"}
~~~~~~~~
import { firstname, lastname } from './file1.js';

console.log(firstname);
// выведет: Robin
~~~~~~~~

Вы также можете импортировать все экспортируемые данные из другого файла в виде одного объекта.

{title="Код: file2.js",lang="javascript"}
~~~~~~~~
import * as person from './file1.js';

console.log(person.firstname);
// выведет: Robin
~~~~~~~~

У выражений импорта могут быть псевдонимы. Может произойти такая ситуация, когда вы импортируете функциональность из нескольких файлов с одним и тем же именем при экспорте. По этой причине вы можете использовать псевдоним.

{title="Код: file2.js",lang="javascript"}
~~~~~~~~
import { firstname as username } from './file1.js';

console.log(username);
// выведет: Robin
~~~~~~~~

И последнее, но не менее важное: существует выражение по умолчанию — `default`. Его можно использовать в следующих случаях:
* для экспорта и импорта единственной функциональной возможности
* для выделения основных функциональных возможностей экспортированного API модуля
* для того, чтобы иметь резервную (фолбэк) функциональность при импорте

{title="Код: file1.js",lang="javascript"}
~~~~~~~~
const robin = {
  firstname: 'Robin',
  lastname: 'Wieruch',
};

export default robin;
~~~~~~~~

Вы можете опустить фигурные скобки при импорте по умолчанию.

{title="Код: file2.js",lang="javascript"}
~~~~~~~~
import developer from './file1.js';

console.log(developer);
// выведет: { firstname: 'Robin', lastname: 'Wieruch' }
~~~~~~~~

Кроме того, название импорта можно различать от экспортированного названия по умолчанию. Вы также можете использовать это в сочетании с именованными выражениями экспорта и импорта.

{title="Код: file1.js",lang="javascript"}
~~~~~~~~
const firstname = 'Robin';
const lastname = 'Wieruch';

const person = {
  firstname,
  lastname,
};

export {
  firstname,
  lastname,
};

export default person;
~~~~~~~~

Затем импортируйте импорт по умолчанию, а также экспорт по имени в другой файл.

{title="Код: file2.js",lang="javascript"}
~~~~~~~~
import developer, { firstname, lastname } from './file1.js';

console.log(developer);
// выведет: { firstname: 'Robin', lastname: 'Wieruch' }
console.log(firstname, lastname);
// выведет: Robin Wieruch
~~~~~~~~

При использовании именованного экспорта вы можете сэкономить дополнительные строки и непосредственно экспортировать переменные.

{title="Код: file1.js",lang="javascript"}
~~~~~~~~
export const firstname = 'Robin';
export const lastname = 'Wieruch';
~~~~~~~~

Это основная функциональность модулей ES6. Они помогают вам организовать собственный код, поддерживать его и проектировать API-интерфейсы повторно используемых модулей. Вы также можете экспортировать и импортировать функциональность для их тестирования. Вы сделаете это в одной из следующих глав.

### Упражнения:

* ознакомьтесь подробнее с [импортом в ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)
* ознакомьтесь подробнее с [экспортом в ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export)

## Организация кода с помощью модулей в ES6

Вы могли бы задаться вопросом: почему мы не последовали передовому опыту разделения кода для файла *src/App.js*? В этом файле у нас уже есть несколько компонентов, которые могут быть определены в собственных файлах/папках (модулях). В интересах изучения React, целесообразно хранить их в одном месте. Но как только ваше приложение React растёт, вам следует рассмотреть возможность разделения этих компонентов на несколько модулей. Только так ваше приложение масштабируется.

Ниже я предлагаю несколько модулей, которые вы *могли* бы применить. Я бы рекомендовал применить их в качестве упражнения в конце книги. Чтобы книга оставалась простой, я не буду выполнять разделение кода и продолжу следующие главы с файлом *src/App.js*.

Одной из возможных структур модулей могла быть такая:

{title="Структура каталогов",lang="text"}
~~~~~~~~
src/
  index.js
  index.css
  App.js
  App.test.js
  App.css
  Button.js
  Button.test.js
  Button.css
  Table.js
  Table.test.js
  Table.css
  Search.js
  Search.test.js
  Search.css
~~~~~~~~

Такой подход разделяет компоненты на отдельные файлы, но он не выглядит слишком перспективным. Вы можете видеть много дублирования названий, которые различаются только расширением файла. Совершенно другой структурой модулей может быть подобное разделение:

{title="Структура каталогов",lang="text"}
~~~~~~~~
src/
  index.js
  index.css
  App/
    index.js
    test.js
    index.css
  Button/
    index.js
    test.js
    index.css
  Table/
    index.js
    test.js
    index.css
  Search/
    index.js
    test.js
    index.css
~~~~~~~~

Это уже выглядит чище, чем предыдущий способ. Файлы с названием index описывает его как файл точки входа в папку (модуль). Это просто обычное соглашение (правило) об наименовании, но вы также можете использовать собственное соглашение. В этой структуре модулей компонент определяется объявлением компонента в файле JavasScript (index.js) , а также его стилем (index.css) и тестами для него (test.js).

Следующим шагом могло бы быть стать извлечение констант из компонента App. Эти константы использовались для формирования URL к API Hacker News.

{title="Структура каталогов",lang="text"}
~~~~~~~~
src/
  index.js
  index.css
# leanpub-start-insert
  constants/
    index.js
  components/
# leanpub-end-insert
    App/
      index.js
      test.js
      index..css
    Button/
      index.js
      test.js
      index..css
    ...
~~~~~~~~

Естественно, что модули бы разделились на *src/constants/* и *src/components/*. Теперь файл *src/constants/index.js* может выглядеть следующим образом:

{title="Код: src/constants/index.js",lang="javascript"}
~~~~~~~~
export const DEFAULT_QUERY = 'redux';
export const DEFAULT_HPP = '100';
export const PATH_BASE = 'https://hn.algolia.com/api/v1';
export const PATH_SEARCH = '/search';
export const PARAM_SEARCH = 'query=';
export const PARAM_PAGE = 'page=';
export const PARAM_HPP = 'hitsPerPage=';
~~~~~~~~

В файле *App/index.js* вы можете импортировать эти константы для использования.

{title="Код: src/components/App/index.js",lang=javascript}
~~~~~~~~
import {
  DEFAULT_QUERY,
  DEFAULT_HPP,
  PATH_BASE,
  PATH_SEARCH,
  PARAM_SEARCH,
  PARAM_PAGE,
  PARAM_HPP,
} from '../constants/index.js';

...
~~~~~~~~

Когда вы используете соглашение по именованию, включающее *index.js*, вы можете опустить название файла из относительно пути.

{title="Код: src/components/App/index.js",lang=javascript}
~~~~~~~~
import {
  DEFAULT_QUERY,
  DEFAULT_HPP,
  PATH_BASE,
  PATH_SEARCH,
  PARAM_SEARCH,
  PARAM_PAGE,
  PARAM_HPP,
# leanpub-start-insert
} from '../constants';
# leanpub-end-insert

...
~~~~~~~~

Но что стоит за именованием файлов *index.js*? Соглашение было введено в мире Node.js. Индексный файл является точкой входа в модуль. Он описывает общедоступный API для модуля. Внешним модулям разрешено использовать файл *index.js* для импорта разделяемого кода из модуля. Рассмотрим следующую составленную структуру модуля, чтобы продемонстрировать её:

{title="Структура каталогов",lang="text"}
~~~~~~~~
src/
  index.js
  App/
    index.js
  Buttons/
    index.js
    SubmitButton.js
    SaveButton.js
    CancelButton.js
~~~~~~~~

В каталоге *Buttons/* есть несколько компонентов, определённых в разных файлах. Каждый файл компонента может использовать `export default`, чтобы его можно было импортировать в файле *Buttons/index.js*. Файл *Buttons/index.js* импортирует все различные представления кнопок и экспортирует их в качестве общедоступного API модуля.

{title="Код: src/Buttons/index.js",lang="javascript"}
~~~~~~~~
import SubmitButton from './SubmitButton';
import SaveButton from './SaveButton';
import CancelButton from './CancelButton';

export {
  SubmitButton,
  SaveButton,
  CancelButton,
};
~~~~~~~~

Теперь из файла *src/App/index.js* можно импортировать кнопки из общедоступного API модуля, расположенного в файле *index.js*.

{title="Код: src/App/index.js",lang=javascript}
~~~~~~~~
import {
  SubmitButton,
  SaveButton,
  CancelButton
} from '../Buttons';
~~~~~~~~

Рассматривая ограничения данного подхода, было бы неудачной практикой импортировать функциональность из других файловых путей, отличных от *index.js*, в модуле. Это нарушит правила инкапсуляции.

{title="Код: src/App/index.js",lang=javascript}
~~~~~~~~
// порочная практика, не делайте так
import SubmitButton from '../Buttons/SubmitButton';
~~~~~~~~

Теперь вы знаете, как можно отрефакторить исходный код в модулях с ограничениями инкапсуляции. Как я уже сказал, ради сохранения простоты в книге я не буду использовать описанные выше изменения. Но вам стоит заняться рефакторингом после прочтения книги.

### Упражнения:

* займитесь рефакторингом файла *src/App.js*, разделив его на несколько модулей-компонентов, когда закончите книгу

## Тестирование снимками с помощью Jest

Данная книга не будет глубоко погружаться в тему тестирования, но это не значит, что её следует игнорировать. Тестирование кода в программировании имеет важное значение и должно рассматриваться в качестве обязательного требования, если вы хотите, чтобы качество вашего кода было высоким и всё работало как надо.

Возможно, вы слышали о пирамиде тестирования. Существуют сквозные (end-to-end), интеграционные (integration) и модульные (unit) тесты. Если вы не знакомы с ними, то в книге приводится быстрый и краткий обзор. Модульный тест служит для проверки изолированного и небольшого куска кода. Это может быть всего лишь одна функция, проверяемая модульным тестом. Тем не менее, иногда модульные тесты работают хорошо в изоляции, но не работают в сочетании с другими модульными тестами. Поэтому их нужно тестировать группой из модульных тестов. Вот где интеграционные тесты могут помочь, учитывая, что они неплохо работают вместе. И последнее, но не менее важное: сквозной тест — это имитация реального использования приложения пользователем. Это может быть автоматическая настройка в браузере, имитирующая процесс входа пользователя в приложение. Если модульные тесты быстро и легко писать и поддерживать, то к сквозным тестам это не относится.

Сколько тестов нужно для каждого типа тестирования? Скорее всего, вы хотите, чтобы было как можно больше модульных тестов для покрытия тестами функций в изоляции. После этого вы можете провести несколько интеграционных тестов, чтобы проверить, что наиболее важные функции работают в сочетании вместе, как ожидалось. И наконец, что немаловажно, вам может потребоваться только несколько сквозных тестов для симулирования критических сценариев использования приложения. На этом общая экскурсия в мир тестирования заканчивается.

Итак, как можно применить полученные знания для тестировании своего приложения на React? Основа тестирования в React — это тесты компонентов, которые можно тестировать модульными тестами, а часть из них — тестированием снимками (snapshot). Вы напишите модульные тесты для своих компонентов в следующей главе, используя библиотеку Enzyme. В этой главе вы остановитесь на другом типе тестов — тестов снимками. Для данного тестирования применяется библиотека под названием Jest.

[Jest](https://jestjs.io/) — это платформа для тестирования JavaScript, используемая и разработанная в Facebook. В сообществе React она используется для тестирования React-компонентов. К счастью, *create-react-app* уже поставляется с Jest, поэтому вам не нужно дополнительно его настраивать.

Давайте начнём тестировать ваши первые компоненты. Прежде чем приступить к этому, вам нужно экспортировать компоненты, которые вы собираетесь тестировать, из файла *src/App.js*. После этого вы можете протестировать их в другом файле. Об этом вы узнали в разделе про организацию кода.

{title="src/App.js",lang=javascript}
~~~~~~~~
...

class App extends Component {
  ...
}

...

export default App;

# leanpub-start-insert
export {
  Button,
  Search,
  Table,
};
# leanpub-end-insert
~~~~~~~~

В файле *App.test.js* вы найдёте ваш первый тест, который появился при инициализации *create-react-app*. Он проверяет, что компонент App отображается без каких-либо ошибок.

{title="src/App.test.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';

it('отрисовывает без ошибки', () => {
  const div = document.createElement('div');
  ReactDOM.render(<App />, div);
  ReactDOM.unmountComponentAtNode(div);
});
~~~~~~~~

Блок «it» представляет собой один тест. Этот блок принимает описание теста и собственно код теста, который может либо пройти успешно, либо потерпеть неудачу (провалиться). Кроме того, вы можете обернуть его в блок «describe», который определяет набор тестов. Набор тестов может включать в себя множество блоков «it» для одного конкретного компонента. Мы рассмотрим блоки «describe» чуть позже. Оба этих блока используются для разделения и организации ваших тестов.

Обратите внимание, что функция `it` считается в сообществе JavaScript функцией, в которой выполняется один тест. Однако в Jest часто встречается псевдоним `test` для функции тестирования.

Вы можете запускать свои тесты с помощью интерактивного скрипта тестирования приложения, предоставляемого *create-react-app* в командной строке. Вам будет показан вывод по каждому тесту в терминале.

{title="Командная строка",lang="text"}
~~~~~~~~
npm test
~~~~~~~~

Теперь Jest позволяет создавать снимки. Эти тесты делают снимок вашего отрисованного компонента и сравнивает этот снимок с будущими снимками. При изменении будущих снимков, будут отображаться соответствующие уведомления в тесте. Вы можете принять изменение снимка, потому что вы специально изменили реализацию компонента, либо отказать в изменении снимка, что означает, что была допущена ошибка, которую нужно исправить. Jest очень хорошо дополняет модульные тесты, потому что проверяются только различия в отрисованных компонентов в разные моменты времени. Кроме того, это не добавляет больших затрат на поддержку таких тестов, потому что вы можете просто принимать изменённые снимки, когда вы намеренно что-то изменили, что повлияло на отрисовку компонента.

Jest хранит снимки в каталоге `snapshots`. Только таким образом он может проверить различия с будущим снимком. Кроме того, снимками можно обмениваться между командами, если они находятся в одной папке.

Перед написанием первого теста снимка с помощью Jest вам необходимо установить следующую библиотеку.

{title="Командная строка",lang="text"}
~~~~~~~~
npm install --save-dev react-test-renderer
~~~~~~~~

Теперь вы можете расширить тест компонента App с помощью своего первого снимка. Во-первых, импортируйте новую функциональность из node-пакета и поместите свой тестируемый код компонента App в блок «it», а его в свою очередь в блок «describe». В данном случае тестовый набор предназначен только для компонента App.

{title="src/App.test.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
# leanpub-start-insert
import renderer from 'react-test-renderer';
# leanpub-end-insert
import App from './App';

# leanpub-start-insert
describe('App', () => {

# leanpub-end-insert
  it('отрисовывает без ошибки', () => {
    const div = document.createElement('div');
    ReactDOM.render(<App />, div);
    ReactDOM.unmountComponentAtNode(div);
  });
# leanpub-start-insert

});
# leanpub-end-insert
~~~~~~~~

Теперь вы можете написать свой первый тест снимком с помощью блока «test».

{title="src/App.test.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import renderer from 'react-test-renderer';
import App from './App';

describe('App', () => {

  it('отрисовывает без ошибки', () => {
    const div = document.createElement('div');
    ReactDOM.render(<App />, div);
    ReactDOM.unmountComponentAtNode(div);
  });

# leanpub-start-insert
  test('есть корректный снимок', () => {
    const component = renderer.create(
      <App />
    );
    const tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });

# leanpub-end-insert
});
~~~~~~~~

Запустите ваши тесты снова и посмотрите, какие из них были выполнены успешно или неудачно. Все они должны пройти. Если вы измените вывод блока отрисовки в компоненте App, тест снимками должен завершиться неудачно. Затем вы можете решить, принять обновление снимка или выяснить причину ошибки в компоненте App.

В основном функция `renderer.create()` создаёт снимок вашего компонента App. Она отрисовывает компонент виртуально и сохраняет полученный DOM в снимок. После этого снимок, как ожидается, будет соответствовать предыдущему снимку с момента последнего запуска проверки снимков. Таким образом, вы можете утверждать, что ваш DOM остался таким же и ничего не поменялось по ошибке.

Давайте добавим больше тестов для наших независимых компонентов. Во-первых, для компонента Search:

{title="src/App.test.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import renderer from 'react-test-renderer';
# leanpub-start-insert
import App, { Search } from './App';
# leanpub-end-insert

...

# leanpub-start-insert
describe('Search', () => {

  it('отрисовывает без ошибки', () => {
    const div = document.createElement('div');
    ReactDOM.render(<Search>Поиск</Search>, div);
    ReactDOM.unmountComponentAtNode(div);
  });

  test('есть корректный снимок', () => {
    const component = renderer.create(
      <Search>Поиск</Search>
    );
    const tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });

});
# leanpub-end-insert
~~~~~~~~

У компонента Search два теста, аналогичных компоненту App. Первый тест просто отрисовывает компонент Search в DOM и проверяет, что во время процесса отрисовки не произошла ошибка. Если ошибка возникла, тест провалится, даже если в тестовом блоке нет никакого утверждения (например, `expect`, `match`, `equal`). Второй — тест снимком — используется для хранения снимка отрисованного компонента и сравнивает его с предыдущего снимком. Этот тест закончится неудачей, когда снимок изменится.

Во-вторых, вы можете протестировать компонент Button, так как применяются те же правила тестирования, что и в компоненте Search.

{title="src/App.test.js",lang=javascript}
~~~~~~~~
...
# leanpub-start-insert
import App, { Search, Button } from './App';
# leanpub-end-insert

...

# leanpub-start-insert
describe('Button', () => {

  it('отрисовывает без ошибки', () => {
    const div = document.createElement('div');
    ReactDOM.render(<Button>Дай мне больше</Button>, div);
    ReactDOM.unmountComponentAtNode(div);
  });

  test('есть корректный снимок', () => {
    const component = renderer.create(
      <Button>Дай мне больше</Button>
    );
    const tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });

});
# leanpub-end-insert
~~~~~~~~

И последнее, но не менее важное: компоненту Table вы можете передать много первоначальных свойств, чтобы отрисовать с демонстрационном списком.

{title="src/App.test.js",lang=javascript}
~~~~~~~~
...
# leanpub-start-insert
import App, { Search, Button, Table } from './App';
# leanpub-end-insert

...

# leanpub-start-insert
describe('Table', () => {

  const props = {
    list: [
      { title: '1', author: '1', num_comments: 1, points: 2, objectID: 'y' },
      { title: '2', author: '2', num_comments: 1, points: 2, objectID: 'z' },
    ],
  };

  it('отрисовывает без ошибки', () => {
    const div = document.createElement('div');
    ReactDOM.render(<Table { ...props } />, div);
  });

  test('есть корректный снимок', () => {
    const component = renderer.create(
      <Table { ...props } />
    );
    const tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });

});
# leanpub-end-insert
~~~~~~~~

Тесты снимком обычно остаются довольно простыми. Вам нужно лишь заметить, что компонент не изменил свой отрисованный вывод. После изменения вывода вы должны решить, принимаете ли вы эти изменения или нет. В противном случае вам нужно исправить компонент, если его вывод отрисовки не такой, как ожидался.

### Упражнения:

* посмотрите, как тест снимком завершится неудачно после изменения возвращаемого значения компонента в методе `render()`
  * и либо примите, либо отклоните изменение снимка
* обновите свои снимки при обновлении компонентов в следующих главах
* узнайте подробнее про использование [Jest в React](https://jestjs.io/docs/en/tutorial-react)

## Модульное тестирование с помощью Enzyme

[Enzyme](https://github.com/airbnb/enzyme) — это утилита тестирования от Airbnb для проверки утверждений, манипулирования и навигации по компонентам React. Вы можете использовать её для проведения модульных тестов в дополнение к вашим снимкам в React.

Давайте посмотрим, как вы можете использовать Enzyme. Сначала нужно установить его, поскольку он не поставляется по умолчанию в *create-react-app*. У Enzyme также есть расширение для использования в React.

{title="Командная строка",lang="text"}
~~~~~~~~
npm install --save-dev enzyme react-addons-test-utils enzyme-adapter-react-16
~~~~~~~~

Во-вторых, вам нужно подключить Enzyme и инициализировать его адаптер для использования в React.

{title="src/App.test.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import renderer from 'react-test-renderer';
# leanpub-start-insert
import Enzyme from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';
# leanpub-end-insert
import App, { Search, Button, Table } from './App';

# leanpub-start-insert
Enzyme.configure({ adapter: new Adapter() });
# leanpub-end-insert
~~~~~~~~

Теперь вы можете написать свой первый модульный тест для компонента Table в блоке «describe». Вы будете использовать `shallow()` для отрисовки вашего компонента и проверять, что у отрисованного компонента Table два элемента, так как ему было передано два элемента списка. Утверждение просто проверяет, есть у элемента таблицы два дочерних элемента с классом `table-row`.

{title="src/App.test.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import renderer from 'react-test-renderer';
# leanpub-start-insert
import Enzyme, { shallow } from 'enzyme';
# leanpub-end-insert
import Adapter from 'enzyme-adapter-react-16';
import App, { Search, Button, Table } from './App';

// ...

describe('Table', () => {

  const props = {
    list: [
      { title: '1', author: '1', num_comments: 1, points: 2, objectID: 'y' },
      { title: '2', author: '2', num_comments: 1, points: 2, objectID: 'z' },
    ],
  };

  ...

# leanpub-start-insert
  it('shows two items in list', () => {
    const element = shallow(
      <Table { ...props } />
    );

    expect(element.find('.table-row').length).toBe(2);
  });
# leanpub-end-insert

});
~~~~~~~~

Функция `shallow` отрисовывает компонент без его дочерних компонентов. Таким образом, вы можете написать тест, проверяющий непосредственно сам компонент.

У Enzyme есть три общих механизма отрисовки, доступные в API. Вы уже знаете `shallow()`, но также существуют `mount()` и `render()`. Они оба создают экземпляры родительского компонента и всех его дочерних компонентов. Кроме того `mount()` предоставляет вам доступ к методам жизненного цикла компонента. Но какой механизм отрисовки использовать? Существует следующие проверенные на практике правила:

* Всегда начинайте с поверхностного (shallow) теста
* Если необходимо проверить `componentDidMount()` или `componentDidUpdate()`, используйте `mount()`
* Если хотите протестировать жизненный цикл компонентов и поведение дочерних элементов, используйте `mount()`
* Если хотите протестировать отрисовку дочерних элементов компонента с меньшими накладными расходами, чем `mount()`, и вам не интересны методы жизненного цикла, используйте `render()`

Вы можете продолжить тестирование своих компонентов. Но следите за тем, чтобы тесты были простыми и удобными для дальнейшей поддержки. В противном случае вам придётся рефакторить их, как только вы измените свои компоненты. Именно поэтому Facebook в первую очередь представил инструмент для тестирования снимками Jest.

### Упражнения:

* напишите модульный тест с использованием Enzyme для компонента Button
* постоянно выполняйте и актуализируйте при необходимости свои модульные тесты в следующих главах
* узнайте больше про [Enzyme и о его API отрисовки](https://github.com/airbnb/enzyme)

## Интерфейс компонента с помощью PropTypes

Возможно вы знаете [TypeScript](https://www.typescriptlang.org/) или [Flow](https://flowtype.org/) для того, чтобы ввести интерфейс типа к JavaScript. Типизированный язык менее подвержен ошибкам, поскольку код проверяется на основе его текста программы. Редакторы и другие утилиты могут поймать эти ошибки до запуска программы. Это делает вашу программу более надёжной.

В книге мы не будем использовать Flow или TypeScript, а вместо этого представим ещё один аккуратный способ проверить свои типы в компонентах. React поставляется со встроенным инструментом проверки типов для предотвращения ошибок. Вы можете использовать PropTypes для описания интерфейса вашего компонента. Все свойства, которые передаются от родительского компонента к дочернему компоненту, проверяются на основе интерфейса PropTypes, назначенному дочернему компоненту.

В разделе этой главы показывается, как вы можете сделать компоненты безопасно типизированными с помощью PropTypes. Я пропускаю данные изменения для следующих глав, потому что они добавляют ненужные улучшения кода. Но вы должны сохранить и обновить их, чтобы сохранить тип интерфейса вашего компонента безопасным.

Во-первых, вам нужно установить отдельный пакет для React.

{title="Командная строка",lang="text"}
~~~~~~~~
npm install prop-types
~~~~~~~~

Теперь вы можете импортировать PropTypes.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import axios from 'axios';
# leanpub-start-insert
import PropTypes from 'prop-types';
# leanpub-end-insert
~~~~~~~~

Давайте установим типы для свойств в компонентах:

{title="src/App.js",lang=javascript}
~~~~~~~~
const Button = ({
  onClick,
  className = '',
  children,
}) =>
  <button
    onClick={onClick}
    className={className}
    type="button"
  >
    {children}
  </button>

# leanpub-start-insert
Button.propTypes = {
  onClick: PropTypes.func,
  className: PropTypes.string,
  children: PropTypes.node,
};
# leanpub-end-insert
~~~~~~~~

В принципе, вот и всё. Вы выбираете каждый аргумент из определения функции и присваиваете ему PropType. Основные PropTypes для примитивных типов данных и сложных объектов перечислены ниже:

* PropTypes.array
* PropTypes.bool
* PropTypes.func
* PropTypes.number
* PropTypes.object
* PropTypes.string

Однако, у вас есть ещё два PropTypes для определения отрисованного фрагмента (узла), например, строка и элемент React:

* PropTypes.node
* PropTypes.element

Вы уже использовали PropType `node` для компонента Button. В целом есть больше определений PropType, про которые вы можете узнать в официальной документации React.

На данный момент все определённые PropTypes для Button — необязательные. Параметры могут быть `null` или `undefined`. Но для нескольких свойств вы можете определить их обязательными. Вы можете установить требование, чтобы эти свойства были переданы компоненту.

{title="src/App.js",lang=javascript}
~~~~~~~~
Button.propTypes = {
# leanpub-start-insert
  onClick: PropTypes.func.isRequired,
# leanpub-end-insert
  className: PropTypes.string,
# leanpub-start-insert
  children: PropTypes.node.isRequired,
# leanpub-end-insert
};
~~~~~~~~

`className` не обязателен, поскольку по умолчанию может быть пустая строка. Далее вы определяете интерфейс PropType для компонента Table:

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
Table.propTypes = {
  list: PropTypes.array.isRequired,
  onDismiss: PropTypes.func.isRequired,
};
# leanpub-end-insert
~~~~~~~~

Вы можете определить содержимое массива PropType более явно:

{title="src/App.js",lang=javascript}
~~~~~~~~
Table.propTypes = {
  list: PropTypes.arrayOf(
    PropTypes.shape({
      objectID: PropTypes.string.isRequired,
      author: PropTypes.string,
      url: PropTypes.string,
      num_comments: PropTypes.number,
      points: PropTypes.number,
    })
  ).isRequired,
  onDismiss: PropTypes.func.isRequired,
};
~~~~~~~~

Требуется только `objectID`, потому что вы знаете, что от этого зависит какой-то ваш код. Другие свойства только отображаются, поэтому они не обязательны. Кроме того, вы не можете быть уверены, что API Hacker News всегда имеет определённое свойство для каждого объекта в массиве.

Это для PropTypes. Но есть ещё один аспект. Вы можете определить свойства по умолчанию в своём компоненте. Давайте снова вернёмся к компоненту Button. У свойства `className` есть значение по умолчанию в объявлении компонента.

{title="src/App.js",lang=javascript}
~~~~~~~~
const Button = ({
  onClick,
  className = '',
  children
}) =>
  ...
~~~~~~~~

Вы можете заменить его внутренним свойством по умолчанию в React:

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
const Button = ({
  onClick,
  className,
  children
}) =>
# leanpub-end-insert
  <button
    onClick={onClick}
    className={className}
    type="button"
  >
    {children}
  </button>

# leanpub-start-insert
Button.defaultProps = {
  className: '',
};
# leanpub-end-insert
~~~~~~~~

Так же, как и параметр по умолчанию в ES6, свойство по умолчанию гарантирует, что для свойства установлено значение по умолчанию, если родительский компонент не указал его. Проверка типа PropType происходит после вычисления свойства по умолчанию.

Если вы снова запустите свои тесты, вы увидите ошибки PropType по вашим компонентам в командной строке. Это может произойти, потому что вы не определили все свойства для своих компонентов в тестах, которые определены в соответствии с вашим определением PropType. Однако сами тесты проходят правильно. Вы можете передать все необходимые свойства компонентам в своих тестах, чтобы избежать этих ошибок.

### Упражнения:

* определите интерфейс PropType для компонента Search
* добавьте и обновите интерфейсы PropType при добавлении и обновлении компонентов в последующих главах
* узнайте больше про [PropTypes в React](https://ru.react.js.org/docs/typechecking-with-proptypes.html)

## Отладка с помощью инструментов разработчика React
 
В этом последнем разделе представлен полезный инструмент, обычно используемый для исследования и отладки React-приложений. [React Developer Tools](https://github.com/facebook/react-devtools) позволяет вам изучать иерархию, свойства и состояние React-компонентов. Он распространяется в виде расширения для браузера (для Chrome и Firefox) и как автономное приложение (которое работает с другими окружениями). После установки на сайтах, разработанных с помощью React, загорится значок расширения. На таких страницах вы увидите вкладку «React» в инструментах разработчика браузера.
 
Давайте попробуем это расширение в вашем приложении Hacker News. В большинстве браузеров быстрый способ загрузить его в *инструменты разработчика* — щёлкнуть правой кнопкой мыши на странице, а затем нажать «Inspect». Сделайте это, когда ваши приложения загружены, затем нажмите вкладку «React». Вы увидите его иерархию элементов с корневым элементом `<App>`. Если вы раскроете его, вы найдёте экземпляры ваших компонентов `<Search>`, `<Table>` и `<Button>`.
 
Расширение показывает на боковой панели состояние компонента и свойства для выбранного элемента. Например, если вы нажмёте на `<App>`, вы увидите, что у него нет свойств, но у него уже есть состояние. Очень простая методика отладки заключается в том, чтобы отслеживать изменение состояния приложения из-за взаимодействия с пользователем.
 
Во-первых, вы можете проверить параметр «Highlight Updates» (обычно над деревом элементов). Во-вторых, вы можете ввести разную строку поиска в поле ввода приложения. Как вы увидите, только `searchTerm` в состоянии компонента будет изменён. Вы уже знаете, что это произойдёт, но теперь вы можете увидеть, что он работает, как и планировалось.
 
Наконец, вы можете нажать кнопку «Search». Состояние `searchKey` будет немедленно изменено для того же значения, что и `searchTerm`, и после этого объект ответа будет добавлен в `results` через несколько секунд. Асинхронный характер вашего кода теперь виден вашим глазам.
 
И последнее, но не менее важное: если вы щёлкните правой кнопкой мыши по любому элементу, то выпадающее меню покажет вам несколько полезных опций. Например, вы можете скопировать свойство или имя элемента, найти соответствующий DOM-узел или перейти к исходному коду приложения в браузере. Этот последний параметр очень полезен для вставки точек останова и отладки ваших функций JavaScript.
 
### Упражнения:
 
* установите расширение [React Developer Tools](https://github.com/facebook/react-devtools) в своём любимом браузере
  * запустите приложение-клон Hacker News и изучите его с помощью расширения
  * поэкспериментируйте с изменениями состояния и свойств
  * следите за тем, что происходит при запуске асинхронного запроса
  * выполните несколько запросов, в том числе повторяющихся. Понаблюдайте за работой механизма кеширования
* Узнайте больше о том, [как отлаживать ваши функции JavaScript в браузере](https://developers.google.com/web/tools/chrome-devtools/javascript/)

{pagebreak}

Вы узнали, как организовать свой код и как его протестировать! Давайте повторим последние темы:

* React
   * PropTypes позволяет вам определять проверки типов для компонентов
   * Jest позволяет писать снимки для ваших компонентов
   * Enzyme позволяет писать модульные тесты для ваших компонентов
   * React Developer Tools — полезный инструмент для отладки
* ES6
   * операции импорта и экспорта помогают организовать ваш код
* Общее
   * организация кода позволяет масштабировать ваше приложение с помощью лучших практик

Исходный код можно найти в [официальном репозитории](https://github.com/the-road-to-learn-react/hackernews-client/tree/5.4).
