# Введение в React

В этой главе даётся введение в React. Вы можете спросить себя: почему я должен изучить React в первую очередь? Эта глава пытается ответить на данный вопрос. После этого вы погрузитесь в экосистему, создав ваше первое React-приложение без какой-либо конфигурации. По ходу дела вы познакомитесь с JSX и ReactDOM. Поэтому будьте готовы к вашим первым компонентам React.

## Привет, меня зовут React.

**Зачем вам нужно изучать React?** В последние годы стали популярны одностраничные приложения ([single-page application, SPA](https://ru.wikipedia.org/wiki/%D0%9E%D0%B4%D0%BD%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5)). Фреймворки, такие как Angular, Ember и Backbone, помогали разработчикам JavaScript создавать современные веб-приложения за пределами использования чистого (ванильного) JavaScript и jQuery. Список этих популярных решений далеко не полный. Существует широкий круг фреймворков для создания SPA. Если посмотреть на даты релизов, то большинство из них относятся к первому поколению SPA: Angular 2010, Backbone 2010 и Ember 2011.

React был изначально выпущен Facebook в 2013 году. React — это не SPA-фреймворк, а библиотека для разработки пользовательских интерфейсов (UI). Это только представление, буква V в аббревиатуре [MVC](https://ru.wikipedia.org/wiki/Model-View-Controller) (Model View Controller). Она позволяет вам отрисовывать (render) компоненты в качестве видимых элементов в браузере. Однако целая экосистема вокруг React позволяет создавать одностраничные приложения.

Но почему вы должны рассмотреть использование React, а не первое поколение SPA-фреймворков? В то время как первое поколение фреймворков пыталось решить сразу много всего, React используется только для создания слоя представления. Это библиотека, а не фреймворк. Идея React заключается в том, что ваше представление представляет собой иерархию составных компонентов.

В React вы можете сосредоточиться на слое представления, перед тем как внедрять остальные концепции в приложение. Каждый новый аспект — это ещё один строительный блок вашего SPA-приложения. Эти строительные блоки необходимы для создания зрелого приложения, и у них есть два преимущества.

Во-первых, вы можете изучать строительные блоки по одному, не понимая их вообще.
Напротив, SPA даёт вам каждый строительный блок с самого начала. В этой книге основное внимание уделяется React как первому строительному блоку. В дальнейшем последует всё больше строительных блоков.

Во-вторых, все строительные блоки взаимозаменяемы, что делает экосистему React очень инновационной. Несколько решений конкурируют друг с другом, и вы можете выбрать наиболее привлекательное решение для вас и вашего варианта использования.

Первое поколение SPA-фреймворков достигло промышленного уровня; такие фреймворки менее гибкие. React остаётся инновационным и используется многими технологическими компаниями-лидерами, такими как [Airbnb, Netflix и, конечно же, Facebook](https://github.com/facebook/react/wiki/Sites-Using-React). Все они инвестируют в будущее React и довольствуются React и его экосистемой.

React — один из лучших выборов для создания современных веб-приложений в настоящее время. Он обеспечивает только уровень представления, [но экосистема React представляет собой гибкий и взаимозаменяемый фреймворк](https://www.robinwieruch.de/essential-react-libraries-framework/). React имеет небольшой API, удивительную экосистему и отличное сообщество. Вы можете прочитать о моём опыте, [почему я перешёл с Angular на React](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/). Я настоятельно рекомендую понять, почему вы выбрали React, а не другой фреймворк или библиотеку. В конце концов, каждый стремится узнать, куда приведёт нас React в ближайшие несколько лет.

### Упражнения

* прочитайте о том, [почему я перешёл с Angular на React](https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/)
* прочитайте о [гибкой экосистеме React](https://www.robinwieruch.de/essential-react-libraries-framework/)
* прочитайте о том, [как изучать фреймворк](https://www.robinwieruch.de/how-to-learn-framework/)

## Требования

Какие требования для чтения этой книги? Прежде всего, вы должны быть знакомы с основами веб-разработки. Вы должны знать, как использовать HTML, CSS и JavaScript. Возможно, имеет смысл также знать, что такое означает термин [API](https://www.robinwieruch.de/what-is-an-api-javascript/), потому что вы будете использовать API в данной книге. Кроме того, я призываю вас вступить в официальную [группу в Slack](https://slack-the-road-to-learn-react.wieruch.com/) этой книги для получения помощи или чтобы помочь другим.

### Редактор и терминал

Как насчёт среды разработки? Вам понадобится работающий редактор или IDE, а также терминал (инструмент командной строки). Вы можете [последовать моему руководству по настройке](https://www.robinwieruch.de/developer-setup/). Он предназначен для пользователей MacOS, но вы также можете найти руководство по настройке для Windows. В целом, есть много статей, которые покажут вам, как наилучшим образом настроить окружение веб-разработки более изысканным способом для используемой вами ОС.

При желании вы можете использовать git для хранения своих проектов и отслеживания прогресса изучения в репозиториях на GitHub, выполняя упражнения этой в книге. Существует [небольшое руководство](https://www.robinwieruch.de/git-essential-commands/) по использованию этих инструментов. Но опять же, это не необязательно для книги и может стать сдерживающим фактором при изучении всего этого с нуля. Вы можете пропустить эту часть, если вы новичок в веб-разработке, чтобы сосредоточиться на основных частях, описанных в книге.

### Node и NPM

И последнее, но не менее важное: вам потребуется установка [node и npm](https://nodejs.org/en/). Оба они используются для управления библиотеками, которые нам понадобятся по ходу дела. В этой книге вы будете устанавливать внешние node-пакеты через npm (node package manager). Эти node-пакеты могут быть библиотеками или целыми фреймворками.

Проверить версии node и npm можно в командной строке. Если вы не видите какой-либо вывод в терминале, вам сначала нужно установить node и npm. Ниже показаны только мои версии, которые я использовал во время написания книги:

{title="Командная строка",lang="text"}
~~~~~~~~
node --version
*v8.9.4
npm --version
*v5.6.0
~~~~~~~~

## node и npm

В этой главе приведён небольшой обзор node и npm. Он не исчерпывающий, но даст вам все необходимые инструменты. Если вы знакомы с обоими из них, то вы можете пропустить этот раздел.

**Менеджер пакетов node** (node package manager, npm) позволяет устанавливать **node-пакеты (node packages)** из командной строки. Эти пакеты могут быть набором утилитарных функций, библиотеками или целыми фреймворками. Все они являются зависимостями для вашего приложения. Вы можете установить все эти зависимости в папку с глобальными или локальными node-пакетами.

Глобальные node-пакеты доступны из любого места в терминале, и их необходимо установить только один раз в глобальный каталог. Вы можете установить глобальный пакет, введя в терминал:

{title="Командная строка",lang="text"}
~~~~~~~~
npm install -g <package>
~~~~~~~~

Флаг `-g` сообщает npm, что пакет нужно установить глобально. Локальные пакеты используются в вашем приложении. Например, React как библиотека будет локальным пакетом, который требуется для работы вашего приложения. Вы можете установить его через терминал, набрав:

{title="Командная строка",lang="text"}
~~~~~~~~
npm install <package>
~~~~~~~~

Команда установки React будет выглядеть следующим образом:

{title="Командная строка",lang="text"}
~~~~~~~~
npm install react
~~~~~~~~

Установленный пакет автоматически появится в папке *node_modules/* и будет перечислен в файле *package.json* вместе с другими зависимостями.

Но как инициализировать папку *node_modules/* и файл *package.json* для проекта в первую очередь? Для этого у нас есть команда npm, инициализирующая проект npm и, следовательно, файл *package.json*. Когда у вас есть этот файл, вы можете установить новые пакеты, используя npm.

{title="Командная строка",lang="text"}
~~~~~~~~
npm init -y
~~~~~~~~

Флаг `-y` — ярлык для инициализации всех значений по умолчанию в *package.json*. Без использования этого флага, вам нужно самому решить, как сконфигурировать этот файл. После инициализации вашего npm-проекта вы готовы к установке новых пакетов через команду `npm install <package>`.

Ещё пару слов об *package.json*. Данный файл позволяет вам поделиться вашим проектом с другими разработчиками без передачи всех node-пакетов. Этот файл содержит все ссылки на пакеты node, используемые в вашем проекте. Эти пакеты называются зависимостями. Каждый может скопировать ваш проект без этих зависимостей. Зависимости — это ссылки в *package.json*. Кто-то, кто копирует ваш проект, может просто установить все пакеты, используя `npm install` в командной строке. Команда `npm install` возьмёт все зависимости, перечисленные в файле *package.json* и установит их в папку *node_modules/*.

Я хочу рассмотреть ещё одну npm-команду:

{title="Командная строка",lang="text"}
~~~~~~~~
npm install --save-dev <package>
~~~~~~~~

Флаг `--save-dev` указывает, что node-пакет используется только в окружении разработки. Он не будет использоваться в продакшене при развёртывании вашего приложения на сервер. Какие node-пакеты должны устанавливаться с помощью этого флага? Представьте, что вы хотите протестировать приложение с помощью node-пакета. Вам нужно установить этот пакет через npm, но вы хотите исключить его из рабочего окружения. Тестирование должно происходить только в процессе разработки, а не тогда, когда приложение уже работает в продакшене. Там вам больше не нужно тестировать приложение. Приложение должно уже быть протестировано и работать из коробки для ваших пользователей. Это как раз тот случай, когда вы захотите использовать флаг `--save-dev`.

Вы столкнётесь с большим количеством npm-команд по ходу чтения, но этого пока будет достаточно.

### Упражнения:

* создайте npm-проект
  * создайте каталог с помощью `mkdir <folder_name>`
  * перейдите в каталог с помощью `cd <folder_name>`
  * выполните `npm init -y` или `npm init`
  * установите локальный пакет React с помощью `npm install react`
  * убедитесь, что существует файл *package.json* и каталог *node_modules/*
  * выясните самостоятельно, как удалить node-пакет *react*
* узнайте больше о [npm](https://docs.npmjs.com/)

## Установка

Существует несколько способов начать работу с приложением React.

Первый из них — использовать CDN. Это может звучать сложнее, чем есть на самом деле. A CDN — [сеть доставки содержимого](https://ru.wikipedia.org/wiki/Content_Delivery_Network). У нескольких компаний есть CDN, которые публично размещают файлы, чтобы люди могли использовать их. Этими файлами могут быть библиотеки, такие как React, поскольку собранная (bundled) библиотека React — это обычный JavaScript-файл *react.js*. Он может быть размещён где-то, и вы можете использовать его в своём приложении.

Как использовать CDN для начала работы с React? Вы можете встроить его в HTML-разметку с помощью тега `<script>`, со ссылкой, которая будет указывать на URL-адрес CDN. Для начала работы с React вам нужны два файла (библиотеки): *react* и *react-dom*.

{title="Код",lang="javascript"}
~~~~~~~~
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
~~~~~~~~

Но почему мы должны использовать CDN, когда есть npm для установки node-пакетов, таких как React?

Когда в приложении есть файл *package.json*, вы можете установить *react* и *react-dom* из командной строки. Однако папка должна быть инициализирована как npm-проект с помощью `npm init -y` с файлом *package.json*. Вы можете установить несколько node-пакетов в одну строку через npm.

{title="Командная строка",lang="text"}
~~~~~~~~
npm install react react-dom
~~~~~~~~

Этот подход часто используется для добавления React в существующее приложение, управляемое с использованием npm.

К сожалению, это ещё не всё. Вам придётся столкнуться с [Babel](http://babeljs.io/) для того, чтобы приложение могло использовать JSX (синтаксис React) и JavaScript ES6. Babel транспилирует (transpiles) ваш код так, чтобы браузеры могли интерпретировать код JavaScript ES6 и JSX, поскольку не все браузеры способны интерпретировать этот синтаксис. Эта установка включает в себя много настроек и инструментов, и для новичков в React это может быть слишком трудным, чтобы возиться со всей этой конфигурацией самостоятельно.

По этой причине Facebook представил *create-react-app* в качестве решения для быстрого запуска создания React-приложений без конфигурации (или как пишут — zero-configuration). В следующей главе будет показано, как настроить приложение, используя этот инструмент для инициализации приложения.

### Упражнения:

* узнайте больше про [установку React](https://ru.reactjs.org/docs/getting-started.html)

## Установка без конфигурации

В нашей книге вы будете использовать [create-react-app](https://github.com/facebookincubator/create-react-app) для начальной инициализации вашего приложения. Это предварительно настроенный без необходимости в ручной конфигурации стартовый набор для React-приложений, представленный Facebook в 2016 году, и согласно опросу в Twitter [рекомендуется 96% начинающим разработчикам React](https://twitter.com/dan_abramov/status/806985854099062785). В *create-react-app* инструменты и конфигурация отходит на задний план, тогда как основное внимание уделяется реализации приложения.

Чтобы начать работу, вам требуется установить пакет в каталог глобальных node-пакетов. После этого вы всегда будете иметь возможность из командной строки инициализировать новое React-приложение.

{title="Командная строка",lang="text"}
~~~~~~~~
npm install -g create-react-app
~~~~~~~~

Вы можете проверить версию *create-react-app*, чтобы убедиться в успешной установке из командной строки:

{title="Командная строка",lang="text"}
~~~~~~~~
create-react-app --version
*v1.5.1
~~~~~~~~

Теперь вы можете инициализировать своё первое React-приложение. Мы назовём его *hackernews*, но вы можете выбрать другое имя. Весь процесс настройки займёт пару секунд. После этого перейдите в папку:

{title="Командная строка",lang="text"}
~~~~~~~~
create-react-app hackernews
cd hackernews
~~~~~~~~

Теперь вы можете открыть приложение в своём редакторе. Будет представлена следующая структура папок или её вариация, в зависимости от версии *create-react-app*:

{title="Структура каталогов",lang="text"}
~~~~~~~~
hackernews/
  README.md
  node_modules/
  package.json
  .gitignore
  public/
    favicon.ico
    index.html
    manifest.json
  src/
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    registerServiceWorker.js
~~~~~~~~

Ниже представлен краткий список каталогов и файлов. Это нормально, если вы не понимаете их все в самом начале.

* **README.md:** Расширение `.md` указывает, что это текстовый файл в формате Markdown. Markdown используется как лёгкий язык разметки с синтаксисом для форматирования текста. Во многих проектах с открытым исходным кодом есть файл *README.md*, чтобы дать пользователям первоначальные инструкции по проекту. Когда вы размещаете свой проект на такой платформе, как GitHub, при открытии репозитория вы увидите визуальное отображение этого файла *README.md*. Поскольку вы использовали  *create-react-app*, ваш *README.md* будет таким же, как в [GitHub-репозитории create-react-app](https://github.com/facebookincubator/create-react-app).

* **node_modules/:** В этой папке находятся все node-пакеты, которые были и будут установлены через npm. Так как вы использовали *create-react-app*, здесь должно уже быть пару установленных node-модулей. Обычно вы никогда не будете иметь дело с этим каталогом, поскольку установка и удаление node-пакетов происходит с помощью пакетных менеджеров (например, npm) из командной строки.

* **package.json:** Данный файл показывает список зависимостей node-пакетов и прочую конфигурационную информацию проекта.

* **.gitignore:** В этом файле указываются все файлы и каталоги, которые не должны быть добавлены в ваш git-репозиторий при использовании git; такие файлы будут находиться только в локальном проекте. Каталог _node_modules/_ как раз является таким каталогом, который должен игнорироваться git. Достаточно, чтобы файл _package.json_ находился под git для возможности совместного использования с вашими коллегами, чтобы они смогли самостоятельно установить все зависимости без разделения с ними папки с зависимостями.

* **public/:** Этот каталог содержит корневые файлы разработки, такие как _public/index.html_. Это индексный файл, который отображается при переходе на localhost:3000 при разработке приложения. Стандартная заготовка (boilerplate) учитывает этот файл, чтобы связать его со всеми скриптами в _src/_.

* **build/** Этот каталог будет создан при сборке проекта для продакшена. Он содержит все готовые файлы при сборке приложения для продакшен-окружения. Весь ваш код, написанный в каталогах _src/_ и _public/_, будет собран (bundled) в пару файлов при выполнении сборки проекта и будут размещены в каталоге build.

* **manifest.json** and **registerServiceWorker.js:** не обращайте внимания на эти файлы на данном этапе, нам они не понадобятся в этом проекте.

Вам не нужно трогать указанные файлы и каталоги. В самом начале всё, что вам нужно, находится в каталоге *src/*. Основное внимание уделяется файлу *src/App.js* для реализации React-компонентов. Он будет использоваться для реализации приложения, но позже вы можете разделить свои компоненты на несколько файлов, тогда каждый файл представляет собой один или несколько компонентов.

Кроме того, вы найдёте файл *src/App.test.js* для своих тестов и *src/index.js* как точку входа (entry point) в мир React. Об этих двух файлах вы узнаете в следующей главе. Вдобавок есть файлы *src/index.css* и *src/App.css* для стилизации общего приложения и ваших компонентов. У всех у них есть стили по умолчанию, если вы их откроете.

Приложение *create-react-app* — проект npm. Вы будете использовать npm для установки и удаления node-пакетов. Кроме того, вместе с ним идут npm-скрипты для выполнения в командной строке:

{title="Командная строка",lang="text"}
~~~~~~~~
# Запускает приложение по адресу http://localhost:3000
npm start

# Запускает выполнение тестов
npm test

# Запускает сборку приложения для продакшена
npm run build
~~~~~~~~

Эти скрипты определены в вашем *package.json*. Теперь заготовка для React-приложения готова к работе. Следующие упражнения позволят вам, наконец, запустить созданное приложение в браузере.

### Упражнения:

* выполните команду `npm start` и перейдите к просмотру приложения в вашем браузере (вы можете выйти из команды, завершить её, нажав на Control + C)
* запустите интерактивный скрипт `npm test`
* запустите скрипт `npm run build` и убедитесь, что в проекте создался каталог *build/* (вы можете удалить его потом; обратите внимание, что каталог сборки может использоваться позже для [развёртывания приложения](https://www.robinwieruch.de/deploy-applications-digital-ocean/))
* ознакомьтесь со структурой каталогов
* ознакомьтесь с содержимым файлов
* узнайте подробнее про [npm-скрипты в пакете create-react-app](https://github.com/facebookincubator/create-react-app)

## Введение в JSX

Теперь вы узнаете о JSX  — синтаксисе React. Как упоминалось ранее, *create-react-app* уже подготовил заготовку приложения для вас. Каждый файл имеет реализацию по умолчанию. Давайте погрузимся в исходный код. Единственным файлом, с которым вы в первую очередь будете работать — *src/App.js*.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">Добро пожаловать в React</h1>
        </header>
        <p className="App-intro">
          Для начала отредактируйте <code>src/App.js</code> и сохраните его для перезагрузки.
        </p>
      </div>
    );
  }
}

export default App;
~~~~~~~~

Не позволяйте себе запутаться в выражениях import/export и объявлении класса. Эти возможности уже JavaScript ES6. Мы рассмотрим их в следующей главе.

В файле есть **React-компонент, определённый через класс ES6** с именем App. Это объявление компонента. В основном после того, как вы объявили компонент, вы можете использовать его в качестве элемента повсюду в своём приложении. Он будет создавать **экземпляр** вашего **компонента** или другими словами: компонент создаёт экземпляр (инстанцируется).

Возвращаемый **элемент** указывается в методе `render()`. Элементы — это то, из чего состоят компоненты. Важно понимать различия между компонентом, экземпляром и элементом.

Довольно скоро вы увидите, где создаётся экземпляр компонента App. В противном случае вы не увидите отрисованный вывод, не так ли? Компонент App — это только объявление, но не его использование. Вы должны инстанцировать компонент где-то в своём JSX с помощью `<App />`.

Содержимое в блоке render выглядит довольно похожим на HTML, но это JSX. JSX позволяет смешивать HTML и JavaScript. Он мощный, но сбивает с толку, когда вы используете его для разделения HTML и JavaScript. Вот почему хорошей отправной точкой считается использовать обычный HTML в JSX. Для начала откройте файл `App.js` и замените HTML-код на тот, который показан ниже.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <h2>Добро пожаловать в Путь к изучению React</h2>
      </div>
    );
  }
}

export default App;
~~~~~~~~

Теперь вы возвращаете только HTML из метода `render()` без всякого JavaScript. Давайте определим "Добро пожаловать в Путь к изучению React" в качестве переменной. Переменная может использоваться в JSX с использованием фигурных скобок.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
# leanpub-start-insert
    var helloWorld = 'Добро пожаловать в Путь к изучению React';
# leanpub-end-insert
    return (
      <div className="App">
# leanpub-start-insert
        <h2>{helloWorld}</h2>
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Он должен заработать, когда вы запустите своё приложение в командной строке с помощью команды `npm start` снова.

Кроме того, вы могли заметить атрибут `className`. Он представляет стандартный атрибут `class` в HTML. По техническим причинам в JSX пришлось заменить несколько встроенных HTML-атрибутов. Вы можете найти все [поддерживаемые HTML-атрибуты в документации к React](https://ru.reactjs.org/docs/dom-elements.html#all-supported-html-attributes). Все они следуют соглашению написания в camelCase. На вашем пути к изучению React, вы столкнётесь с некоторыми специфическими атрибутами JSX.

### Упражнения:

* определите больше переменных и отрисуйте их в вашем JSX
  * используйте сложный объект для представления пользователя с именем и фамилией
  * отобразите свойства пользователя в своём JSX
* ознакомьтесь подробнее с синтаксисом [JSX](https://ru.reactjs.org/docs/introducing-jsx.html)
* узнайте больше про [компоненты, элементы и экземпляры в React](https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html)

## const и let в ES6

Я думаю, вы заметили, что мы объявили переменную `helloWorld`, используя выражение `var`. В JavaScript ES6 появилось два варианта для определения переменных: `const` и `let`. В JavaScript ES6 вы редко теперь найдёте использование `var` для определения переменных.

Переменная, объявленная с помощью `const`, не может быть повторно объявлена или изменена (она неизменяемая). Как только структура данных определена, вы не сможете её изменить.

{title="Код",lang="javascript"}
~~~~~~~~
// изменение не разрешено
const helloWorld = 'Добро пожаловать в Путь к изучению React';
helloWorld = 'Пока-пока, React';
~~~~~~~~

Переменная, объявленная с помощью `let`, может быть изменена.

{title="Код",lang="javascript"}
~~~~~~~~
// изменение разрешено
let helloWorld = 'Добро пожаловать в Путь к изучению React';
helloWorld = 'Пока-пока, React';
~~~~~~~~

Вам стоит объявлять переменные через `let`, если потребуется позже повторно переназначить переменную.

Однако нужно быть аккуратнее с `const`. Переменная, объявленная с использованием `const` не может быть изменена. Но в случае, если эта переменная — массив или объект, значение изменится как обычно. Подобное значение не является неизменяемым.

{title="Код",lang="javascript"}
~~~~~~~~
// изменение разрешено
const helloWorld = {
  text: 'Добро пожаловать в Путь к изучению React'
};
helloWorld.text = 'Пока-пока, React';
~~~~~~~~

Но в каких случаях следует использовать тот или иной способ определения переменной? Существуют разные мнения на этот счёт. Я предлагаю использовать `const` каждый раз при определении переменной. Это будет означать, что вы хотите иметь неизменяемую структуру данных, даже несмотря на то, что значения в объектах и массивах могут изменяться. Если переменная будет изменяемой, то вы можете использовать `let`.

Неизменяемость охватывает React и его экосистему. Вот почему `const` должен быть вашим выбором по умолчанию при определении переменной. Тем не менее, в сложных объектах значения внутри могут быть изменены. Будьте осторожны с этим поведением.

В вашем приложении используйте `const` вместо `var`.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

class App extends Component {
  render() {
# leanpub-start-insert
    const helloWorld = 'Добро пожаловать в Путь к изучению React';
# leanpub-end-insert
    return (
      <div className="App">
        <h2>{helloWorld}</h2>
      </div>
    );
  }
}

export default App;
~~~~~~~~

### Упражнения:

* узнайте больше о [выражении const в ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/const)
* узнайте больше о [выражении let в ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let)
* узнайте подробнее про неизменяемые структуры данных
  * почему они вообще имеют смысл в программировании
  * почему они используются в React и его экосистеме

## ReactDOM

Прежде чем продолжить с компонентом App, возможно, вы захотите посмотреть, где он используется. Он используется в вашей точке входа в мир React — в файле *src/index.js*.

{title="src/index.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);
~~~~~~~~

В основном `ReactDOM.render()` использует DOM-узел в вашей HTML-разметке для замены его вашим JSX. Вот так легко вы можете интегрировать React в любое стороннее приложение. Не запрещается использовать `ReactDOM.render()` несколько раз в приложении. Вы можете использовать его в нескольких местах для начальной загрузки простого JSX-синтаксиса, React-компонента, нескольких React-компонентов или всего приложения. Но в простом React-приложении вы будете использовать его только один раз для инициализации всего дерева компонентов.

`ReactDOM.render()` ожидает два аргумента. Первый аргумент — JSX, который будет отрисовываться. Второй аргумент указывает место, где React-приложение привяжется к вашему HTML. Он ожидает элемент с `id='root'`. Вы можете открыть файл *public/index.html*, чтобы найти этот атрибут.

В текущей реализации `ReactDOM.render()` уже принимает компонент App. Тем не менее, было бы неплохо передать более простой JSX. Это необязательно должно быть инстанцирование компонента.

{title="Код",lang=javascript}
~~~~~~~~
ReactDOM.render(
  <h1>Привет, мир React</h1>,
  document.getElementById('root')
);
~~~~~~~~

### Упражнения:

* откройте файл *public/index.html*, чтобы посмотреть, где React-приложение монтируется в HTML
* узнайте больше про [отрисовку элементов в React](https://ru.reactjs.org/docs/rendering-elements.html)

## Горячая перезагрузка

Горячая перезагрузка модулей (Hot Module Replacement, HMR) — это то, что вы в качестве разработчика можете сделать в файле *src/index.js* для улучшения процесса разработки.

По умолчанию *create-react-app* заставит обновлять страницу в браузере при изменении исходного кода. Попробуйте сами, изменив переменную `helloWorld` в файле *src/App.js*. Браузер должен обновить содержимое страницы. Но есть лучший способ сделать это.

Горячая перезагрузка модулей или замена модулей без полной перезагрузки страницы — это инструмент для перезагрузки приложения в браузере. Браузер не выполняет обновление страницы. Вы можете легко активировать его в *create-react-app*. В *src/index.js*, точке входа React, вы можете добавить следующую настройку.

{title="src/index.js",lang=javascript}
~~~~~~~~
import React from 'react';
import ReactDOM from 'react-dom';
import App from './App';
import './index.css';

ReactDOM.render(
  <App />,
  document.getElementById('root')
);

# leanpub-start-insert
if (module.hot) {
  module.hot.accept();
}
# leanpub-end-insert
~~~~~~~~

Вот и всё. Повторите попытку изменить переменную `helloWorld` в файле *src/App.js*. Браузер не должен обновить страницу, но приложение перезагрузится и покажет корректный (актуальный) вывод. У HMR есть несколько преимуществ:

Представьте, что делаете отладку кода с использованием выражений `console.log()`. Эти выражения останутся в консоли разработчика, даже если вы изменили код, потому что браузер больше не обновляет страницу. Это может быть удобно для целей отладки.

В развивающемся приложении обновление страницы задерживает вашу продуктивность. Вы должны подождать, пока страница загрузится. Перезагрузка страницы может занять несколько секунд в большом приложении. HMR устраняет этот недостаток.

Наконец, самое большое преимущество HMR в том, что вы можете сохранить состояние после перезагрузки приложения. Представьте, что у вас есть диалоговое окно в вашем приложении с несколькими шагами, и вы находитесь на шаге 3. В целом, это напоминает мастер настройки. Без HMR вы измените исходный код, и браузер обновит страницу. Вам нужно снова открыть диалоговое окно и перейти с шага 1 на шаг 3. С использованием HMR диалоговое окно остаётся открытым на шаге 3. Он сохраняет состояние приложения, даже если исходный код изменяется. Перезагружается только само приложение, а не страница.

### Упражнения:

* измените исходный код *src/App.js* несколько раз, чтобы увидеть работу HMR в действии
* посмотрите первые 10 минут видеоролика (на английском) Дэна Абрамова (Dan Abramov) [Live React: Hot Reloading with Time Travel](https://www.youtube.com/watch?v=xsSnOQynTHs)

## Комплексный JavaScript в JSX

Вернёмся к нашему компоненту App. До сих пор вы отрисовывали некоторые примитивные переменные в вашем JSX. Теперь вы начнёте отрисовывать список элементов. В начале список будет состоять из демонстрационных данных, но позже данные вы будете получать из внешнего [API](https://www.robinwieruch.de/what-is-an-api-javascript/), что будет намного интереснее.

Сначала определим список элементов.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';
import './App.css';

# leanpub-start-insert
const list = [
  {
    title: 'React',
    url: 'https://reactjs.org/',
    author: 'Jordan Walke',
    num_comments: 3,
    points: 4,
    objectID: 0,
  },
  {
    title: 'Redux',
    url: 'https://redux.js.org/',
    author: 'Dan Abramov, Andrew Clark',
    num_comments: 2,
    points: 5,
    objectID: 1,
  },
];
# leanpub-end-insert

class App extends Component {
  ...
}
~~~~~~~~

Демо-данные представляют данные, которые будут получены позже из API. У элемента в списке есть заголовок, ссылка и автор. Кроме того, он содержит идентификатор, баллы (которые указывают, насколько популярна статья) и количество комментариев.

Теперь вы можете использовать встроенную функцию JavaScript `map` в JSX. Она позволяет перебирать список элементов для их отображения. Снова вы будете использовать фигурные скобки для вставки (инкапсуляции) JavaScript-выражений в вашем JSX.

{title="src/App.js",lang=javascript}
~~~~~~~~
class App extends Component {
  render() {
    return (
      <div className="App">
# leanpub-start-insert
        {list.map(function (item) {
          return <div>{item.title}</div>;
        })}
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Использование JavaScript вместе с HTML очень эффективно в JSX. Вы могли использовать `map` для преобразования одного списка элементов в другой список элементов. Но на этот раз вы можете использовать `map` для преобразования списка элементов в HTML-элементы.

Пока что для каждого элемента отображается `title`. Давайте отобразим ещё больше свойств элементов.

{title="src/App.js",lang=javascript}
~~~~~~~~
class App extends Component {
  render() {
    return (
      <div className="App">
# leanpub-start-insert
        {list.map(function (item) {
          return (
            <div>
              <span>
                <a href={item.url}>{item.title}</a>
              </span>
              <span>{item.author}</span>
              <span>{item.num_comments}</span>
              <span>{item.points}</span>
            </div>
          );
        })}
# leanpub-end-insert
      </div>
    );
  }
}

export default App;
~~~~~~~~

Вы видите, что функция `map` просто встроена в ваш JSX. Каждое свойство элемента отображается в теге `<span>`. Кроме того, свойство url элемента используется в атрибуте `href` тега `<a>`.

React выполнит всю работу за вас и отобразит каждый элемент, но вы должны добавить одного помощника для React, чтобы полностью использовать его потенциал и улучшить его производительность. Вы должны назначить атрибут key для каждого элемента списка. Таким образом, React может идентифицировать добавленные, изменённые и удалённые элементы при изменении списка. У элементов списка демо-данных уже есть идентификатор.

{title="src/App.js",lang=javascript}
~~~~~~~~
{list.map(function (item) {
  return (
# leanpub-start-insert
    <div key={item.objectID}>
# leanpub-end-insert
      <span>
        <a href={item.url}>{item.title}</a>
      </span>
      <span>{item.author}</span>
      <span>{item.num_comments}</span>
      <span>{item.points}</span>
    </div>
  );
})}
~~~~~~~~

Вы должны убедиться, что атрибут key — уникальный идентификатор. Не допускайте ошибку, использовав индекс элемента в массиве. Индекс массива вообще непостоянный. Например, когда список изменяет свой порядок, React будет трудно идентифицировать элементы правильно.

{title="src/App.js",lang=javascript}
~~~~~~~~
// не делайте так
{list.map(function (item, key) {
  return (
    <div key={key}>
      ...
    </div>
  );
})}
~~~~~~~~

Теперь вы отображаете оба списка. Вы можете запустить приложение, открыть браузер и увидеть оба элемента списка.

### Упражнения:

* узнайте подробнее про [списки и ключи React](https://ru.reactjs.org/docs/lists-and-keys.html)
* повторите [стандартные встроенные функции массива в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/)
* используйте больше JavaScript-выражений в JSX

## Стрелочные функции ES6

В стандарте ES6 появились стрелочные функции (arrow functions). Выражение стрелочной функции короче функциональных выражений.

{title="Код",lang="javascript"}
~~~~~~~~
// объявление функции
function () { ... }

// объявление стрелочной функции
() => { ... }
~~~~~~~~

Вам необходимо знать о функциональности стрелочных функций. Одна из их особенностей — это другое поведение с объектом `this`. Функция всегда определяет свой собственный объект `this`.Стрелочная функция получает значение `this` из окружающего контекста.

Есть ещё один важный факт о стрелочных функций, касающийся круглых скобок. Вы можете удалить круглые скобки, когда функция принимает только один аргумент, но их нужно оставить в случае, если стрелочная функция принимает несколько аргументов (или ни одного — прим. пер.).

{title="Код",lang="javascript"}
~~~~~~~~
// разрешено
item => { ... }

// разрешено
(item) => { ... }

// не разрешено
item, key => { ... }

// разрешено
(item, key) => { ... }
~~~~~~~~

Давайте посмотрим на функцию `map`. Вы можете написать её более кратко с помощью стрелочных функций из ES6.

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
{list.map(item => {
# leanpub-end-insert
  return (
    <div key={item.objectID}>
      <span>
        <a href={item.url}>{item.title}</a>
      </span>
      <span>{item.author}</span>
      <span>{item.num_comments}</span>
      <span>{item.points}</span>
    </div>
  );
})}
~~~~~~~~

Кроме того, вы можете удалить *тело блока*, то есть фигурные скобки стрелочной функции ES6. В *сокращённом теле блока* подразумевается неявный возврат. Таким образом, вы можете удалить выражение `return`. Такая форма стрелочной функции в книге будет использоваться чаще, поэтому убедитесь, что понимаете разницу между телом блока и сокращённым телом блока при использовании стрелочных функций.

{title="src/App.js",lang=javascript}
~~~~~~~~
# leanpub-start-insert
{list.map(item =>
# leanpub-end-insert
  <div key={item.objectID}>
    <span>
      <a href={item.url}>{item.title}</a>
    </span>
    <span>{item.author}</span>
    <span>{item.num_comments}</span>
    <span>{item.points}</span>
  </div>
# leanpub-start-insert
)}
# leanpub-end-insert
~~~~~~~~

Теперь ваш JSX выглядит более кратким и читаемым. В нём нет выражения `function`, фигурных скобок и выражения `return`. Вместо это разработчик может сосредоточиться на деталях реализации.

### Упражнения:

* изучите подробнее [стрелочные функции ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

## Классы ES6

В стандарте ES6 появился синтаксис классов. Класс обычно используется в объектно-ориентированных языках программирования. JavaScript был и есть очень гибкий в своих парадигмах программирования. Вы можете использовать функциональное программирование и объектно-ориентированное программирование бок о бок, в зависимости от конкретных случаев использования.

Несмотря на то, что React охватывает функциональное программирование, например, с неизменяемыми структурами данных, классы используются для объявления компонентов. Они называются компонентами класса ES6 или классовыми компонентами ES6. React смешивает хорошие части этих парадигм программирования.

Давайте рассмотрим следующий класс Developer для изучения классов JavaScript ES6, не думая о компоненте.

{title="Код",lang="javascript"}
~~~~~~~~
class Developer {
  constructor(firstname, lastname) {
    this.firstname = firstname;
    this.lastname = lastname;
  }

  getName() {
    return this.firstname + ' ' + this.lastname;
  }
}
~~~~~~~~

У класса есть конструктор, чтобы сделать его инстанцируемым (иметь возможность создавать из него объекты — прим. пер.). Конструктор может принимать аргументы, чтобы их можно было в качестве свойств назначить экземпляру класса. Кроме того, в классе можно определять функции. Поскольку функция связана с классом, она называется методом. Часто он упоминается как метод класса.

Класс Developer — это только объявление класса. Вы можете создать несколько экземпляров класса путём его вызова. Он похож на компонент класса ES6, который имеет объявление, но вы должны использовать его в другом месте для создания экземпляра.

Давайте посмотрим, как вы можете создать экземпляр класса и как использовать его методы.

{title="Код",lang="javascript"}
~~~~~~~~
const robin = new Developer('Robin', 'Wieruch');
console.log(robin.getName());
// выведет: Robin Wieruch
~~~~~~~~

React использует классы JavaScript ES6 для классов-компонентов. Вы уже использовали один ES6-класс компонента.

{title="src/App.js",lang=javascript}
~~~~~~~~
import React, { Component } from 'react';

...

class App extends Component {
  render() {
    ...
  }
}
~~~~~~~~

Класс App наследует `Component`. В основном, когда вы объявляете компонент App, он наследуется от другого компонента. Что значит "наследуется"? В объектно-ориентированном программировании у вас есть принцип наследования, который означает, что функциональные возможности могут передаваться из одного класса в другой.

Класс App наследует функциональность из класса Component. Более конкретно — он наследует функциональность из класса Component. Класс Component используется для наследования базового класса ES6 в класс компонента ES6. Он имеет всю функциональность, которую имеет компонент в React. Метод render — одна из тех функциональностей, которые вы уже использовали. В дальнейшем вы узнаете о других методах класса компонента.

Класс `Component` инкапсулирует все детали реализации компонента React. Это позволяет разработчикам использовать классы как компоненты в React.

Методы, предоставляемые компонентом `Component`, являются открытым интерфейсом. Один из этих методов должен быть переопределён, другие не должны быть переопределены. Вы узнаете о последних методах, когда позже в этой книге будут рассматриваться методы жизненного цикла. Метод `render()` должен быть переопределён, поскольку он определяет вывод компонента React `Component`.

В данный момент вы узнали об основах классов JavaScript ES6 и о том, как они используются в React для создания компонентов. Вы узнаете подробнее о методах Component, когда в книге будут описаны методы жизненного цикла React.

### Упражнения:

* узнайте получше [классы в ES6](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes)
* убедитесь, что знаете хорошо [основы JavaScript перед тем как перейти к изучению React](https://www.robinwieruch.de/javascript-fundamentals-react-requirements/)

{pagebreak}

Вы научились создавать своё собственное React-приложение! Давайте вспомним последние темы:

* React
  * create-react-app для создания заготовки приложения React
  * JSX смешивает HTML и JavaScript для определения вывода React-компонентов в своих методах render
  * компоненты, экземпляры и элементы — разные понятия в React
  * `ReactDOM.render()` — это точка входа для React-приложения, которая привязывает React к DOM
  * встроенная функциональность JavaScript может использоваться в JSX
    * функцию `map` можно использовать для отрисовки списка элементов как HTML-элементов
* ES6
  * объявления переменных с помощью `const` и `let` могут использоваться в зависимости от конкретных случаев
    * использование `const` вместо `let` в React-приложениях
  * стрелочные функции используются для краткого написания ваших функций
  * классы используются для определения компонентов в React путём их наследования

На данном этапе имеет смысл сделать перерыв. Усвоить полученные знания и применить их на практике самостоятельно. Вы можете поэкспериментировать с исходным кодом, написанным в рамках этой главы. Его можно найти в [официальном репозитории](https://github.com/the-road-to-learn-react/hackernews-client/tree/5.1).
